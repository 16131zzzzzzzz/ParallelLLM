"""
测试目标: Provider测试基类 - 抽象基类，不包含具体测试
- 为所有Provider测试提供统一的测试框架
- 定义通用的测试方法和设置
- 不应直接运行此文件，只作为基类使用
- Provider测试应继承此类并实现具体的测试逻辑

注意: 此文件已被废弃，provider测试已移至provider_tests目录
可以考虑删除此文件，因为新的provider测试不再依赖此基类
"""
import unittest
from unittest.mock import AsyncMock, patch
import asyncio
import os
import sys
import tempfile
from abc import ABC, abstractmethod
from typing import Dict, Any, List

# 添加项目根目录和tests目录到Python路径
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
sys.path.insert(0, os.path.dirname(__file__))

from conftest import TestConfig, mock_chat_response, mock_embedding_response
from pllm import Client


class BaseProviderTest(unittest.IsolatedAsyncioTestCase, ABC):
    """Provider测试基类"""
    
    # 防止unittest发现此基类作为测试运行
    __test__ = False
    
    @property
    @abstractmethod
    def provider_name(self) -> str:
        """提供商名称"""
        pass
    
    @property
    @abstractmethod
    def supports_embedding(self) -> bool:
        """是否支持embedding"""
        pass
    
    @property
    @abstractmethod
    def mock_api_base(self) -> str:
        """Mock API基础URL"""
        pass
    
    async def asyncSetUp(self):
        """测试初始化"""
        self.temp_dir = tempfile.TemporaryDirectory()
        self.config = self._create_provider_config()
        self.config_path = TestConfig.write_temp_config(self.config)
        self.client = Client(self.config_path)
        
        # 启动健康检查任务
        if hasattr(self.client.balancer, '_health_check_coro'):
            self.health_check_task = asyncio.create_task(
                self.client.balancer._health_check_coro()
            )
    
    async def asyncTearDown(self):
        """测试清理"""
        if hasattr(self, 'health_check_task'):
            self.health_check_task.cancel()
            try:
                await self.health_check_task
            except asyncio.CancelledError:
                pass
        
        self.temp_dir.cleanup()
        if os.path.exists(self.config_path):
            os.unlink(self.config_path)
    
    def _create_provider_config(self) -> Dict[str, Any]:
        """创建单个提供商的配置"""
        return {
            "llm": {
                "use": self.provider_name,
                self.provider_name: [
                    {
                        "api_key": f"sk-mock-{self.provider_name}-key",
                        "api_base": self.mock_api_base,
                        "model": self._get_default_model(),
                        "rate_limit": 10
                    }
                ]
            }
        }
    
    @abstractmethod
    def _get_default_model(self) -> str:
        """获取默认模型"""
        pass
    
    @patch("aiohttp.ClientSession.post")
    async def test_chat(self, mock_post):
        """测试聊天功能"""
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = mock_chat_response("Hello from " + self.provider_name)
        mock_post.return_value.__aenter__.return_value = mock_response
        
        messages = [{"role": "user", "content": "Hello"}]
        response = await self.client.chat(messages)
        
        self.assertIsInstance(response, str)
        self.assertIn(self.provider_name, response)
        mock_post.assert_called_once()
    
    @patch("aiohttp.ClientSession.post") 
    async def test_generate(self, mock_post):
        """测试生成功能"""
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = mock_chat_response(f"Generated by {self.provider_name}")
        mock_post.return_value.__aenter__.return_value = mock_response
        
        response = await self.client.generate("Tell me a joke")
        
        self.assertIsInstance(response, str)
        self.assertIn(self.provider_name, response)
        mock_post.assert_called_once()
    
    @patch("aiohttp.ClientSession.post")
    async def test_embedding(self, mock_post):
        """测试embedding功能"""
        if not self.supports_embedding:
            with self.assertRaises((NotImplementedError, AttributeError)):
                await self.client.embedding("test text")
            return
        
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = mock_embedding_response()
        mock_post.return_value.__aenter__.return_value = mock_response
        
        response = await self.client.embedding("test text")
        
        self.assertIsInstance(response, list)
        self.assertTrue(len(response) > 0)
        self.assertIsInstance(response[0], float)
        mock_post.assert_called_once()
    
    def test_sync_methods(self):
        """测试同步方法"""
        # 测试同步生成
        with patch.object(self.client, 'generate', new_callable=AsyncMock) as mock_generate:
            mock_generate.return_value = f"Sync response from {self.provider_name}"
            result = self.client.generate_sync("test prompt")
            self.assertEqual(result, f"Sync response from {self.provider_name}")
        
        # 测试同步聊天
        with patch.object(self.client, 'chat', new_callable=AsyncMock) as mock_chat:
            mock_chat.return_value = f"Sync chat from {self.provider_name}"
            result = self.client.chat_sync([{"role": "user", "content": "hi"}])
            self.assertEqual(result, f"Sync chat from {self.provider_name}")
        
        # 测试同步embedding（如果支持）
        if self.supports_embedding:
            with patch.object(self.client, 'embedding', new_callable=AsyncMock) as mock_embed:
                mock_embed.return_value = [0.1, 0.2, 0.3]
                result = self.client.embedding_sync("test")
                self.assertEqual(result, [0.1, 0.2, 0.3])
    
    @patch("aiohttp.ClientSession.post")
    async def test_error_handling(self, mock_post):
        """测试错误处理"""
        # 模拟API错误
        mock_post.side_effect = Exception("API Error")
        
        with self.assertRaises(Exception):
            await self.client.generate("test prompt")
    
    def test_stats_tracking(self):
        """测试统计信息跟踪"""
        stats = self.client.get_stats()
        self.assertIsInstance(stats, dict)
        
        if self.provider_name in stats:
            provider_stats = stats[self.provider_name]
            self.assertIsInstance(provider_stats, list)
            
            for client_stat in provider_stats:
                self.assertIn("total_requests", client_stat)
                self.assertIn("total_tokens", client_stat)
                self.assertIn("error_count", client_stat)
                self.assertIn("active", client_stat)